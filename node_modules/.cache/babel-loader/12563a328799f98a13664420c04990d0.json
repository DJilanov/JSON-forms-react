{"ast":null,"code":"\"use strict\";\n\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/*\n  The MIT License\n  \n  Copyright (c) 2017-2019 EclipseSource Munich\n  https://github.com/eclipsesource/jsonforms\n  \n  Permission is hereby granted, free of charge, to any person obtaining a copy\n  of this software and associated documentation files (the \"Software\"), to deal\n  in the Software without restriction, including without limitation the rights\n  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n  copies of the Software, and to permit persons to whom the Software is\n  furnished to do so, subject to the following conditions:\n  \n  The above copyright notice and this permission notice shall be included in\n  all copies or substantial portions of the Software.\n  \n  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n  THE SOFTWARE.\n*/\n\nvar cloneDeep_1 = __importDefault(require(\"lodash/cloneDeep\"));\n\nvar set_1 = __importDefault(require(\"lodash/set\"));\n\nvar get_1 = __importDefault(require(\"lodash/get\"));\n\nvar filter_1 = __importDefault(require(\"lodash/filter\"));\n\nvar isEqual_1 = __importDefault(require(\"lodash/isEqual\"));\n\nvar isFunction_1 = __importDefault(require(\"lodash/isFunction\"));\n\nvar actions_1 = require(\"../actions\");\n\nvar validator_1 = require(\"../util/validator\");\n\nvar validate = function validate(validator, data) {\n  var valid = validator(data);\n\n  if (valid) {\n    return [];\n  }\n\n  return validator.errors;\n};\n\nexports.sanitizeErrors = function (validator, data) {\n  return validate(validator, data).map(function (error) {\n    error.dataPath = error.dataPath.replace(/\\//g, '.').substr(1);\n    return error;\n  });\n};\n\nvar alwaysValid = function alwaysValid() {\n  return true;\n};\n\nvar initState = {\n  data: {},\n  schema: {},\n  uischema: undefined,\n  errors: [],\n  validator: alwaysValid,\n  ajv: undefined,\n  refParserOptions: undefined\n};\n\nvar getOrCreateAjv = function getOrCreateAjv(state, action) {\n  if (action) {\n    if (hasAjvOption(action.options)) {\n      // options object with ajv\n      return action.options.ajv;\n    } else if (action.options !== undefined && !hasRefParserOption(action.options)) {\n      // it is not an option object => should be ajv itself => check for compile function\n      if (isFunction_1.default(action.options.compile)) {\n        return action.options;\n      }\n    }\n  }\n\n  if (state.ajv) {\n    return state.ajv;\n  }\n\n  return validator_1.createAjv();\n};\n\nvar getRefParserOptions = function getRefParserOptions(state, action) {\n  if (action && hasRefParserOption(action.options)) {\n    return action.options.refParserOptions;\n  }\n\n  return state.refParserOptions;\n};\n\nvar hasRefParserOption = function hasRefParserOption(option) {\n  if (option) {\n    return option.refParserOptions !== undefined;\n  }\n\n  return false;\n};\n\nvar hasAjvOption = function hasAjvOption(option) {\n  if (option) {\n    return option.ajv !== undefined;\n  }\n\n  return false;\n};\n\nexports.coreReducer = function (state, action) {\n  if (state === void 0) {\n    state = initState;\n  }\n\n  switch (action.type) {\n    case actions_1.INIT:\n      {\n        var thisAjv = getOrCreateAjv(state, action);\n        var v = thisAjv.compile(action.schema);\n        var e = exports.sanitizeErrors(v, action.data);\n        var o = getRefParserOptions(state, action);\n        return __assign({}, state, {\n          data: action.data,\n          schema: action.schema,\n          uischema: action.uischema,\n          errors: e,\n          validator: v,\n          ajv: thisAjv,\n          refParserOptions: o\n        });\n      }\n\n    case actions_1.SET_AJV:\n      {\n        var currentAjv = action.ajv;\n        var validator = currentAjv.compile(state.schema);\n        var errors = exports.sanitizeErrors(validator, state.data);\n        return __assign({}, state, {\n          validator: validator,\n          errors: errors\n        });\n      }\n\n    case actions_1.SET_SCHEMA:\n      {\n        var v = action.schema && state.ajv ? state.ajv.compile(action.schema) : state.validator;\n        return __assign({}, state, {\n          validator: v,\n          schema: action.schema\n        });\n      }\n\n    case actions_1.SET_UISCHEMA:\n      {\n        return __assign({}, state, {\n          uischema: action.uischema\n        });\n      }\n\n    case actions_1.UPDATE_DATA:\n      {\n        if (action.path === undefined || action.path === null) {\n          return state;\n        } else if (action.path === '') {\n          // empty path is ok\n          var result = action.updater(cloneDeep_1.default(state.data));\n\n          if (result === undefined || result === null) {\n            return __assign({}, state, {\n              data: state.data,\n              uischema: state.uischema,\n              schema: state.schema\n            });\n          }\n\n          var errors = exports.sanitizeErrors(state.validator, result);\n          return __assign({}, state, {\n            data: result,\n            errors: errors\n          });\n        } else {\n          var oldData = get_1.default(state.data, action.path);\n          var newData = action.updater(cloneDeep_1.default(oldData));\n          var newState = set_1.default(cloneDeep_1.default(state.data), action.path, newData);\n          var errors = exports.sanitizeErrors(state.validator, newState);\n          return __assign({}, state, {\n            data: newState,\n            errors: errors\n          });\n        }\n      }\n\n    case actions_1.UPDATE_ERRORS:\n      {\n        return __assign({}, state, {\n          errors: action.errors\n        });\n      }\n\n    default:\n      return state;\n  }\n};\n\nexports.extractData = function (state) {\n  return get_1.default(state, 'data');\n};\n\nexports.extractSchema = function (state) {\n  return get_1.default(state, 'schema');\n};\n\nexports.extractUiSchema = function (state) {\n  return get_1.default(state, 'uischema');\n};\n\nexports.errorsAt = function (instancePath, schema, matchPath) {\n  return function (errors) {\n    var combinatorPaths = filter_1.default(errors, function (error) {\n      return error.keyword === 'oneOf' || error.keyword === 'anyOf';\n    }).map(function (error) {\n      return error.dataPath;\n    });\n    return filter_1.default(errors, function (error) {\n      var result = matchPath(error.dataPath);\n\n      if (combinatorPaths.findIndex(function (p) {\n        return instancePath.startsWith(p);\n      }) !== -1) {\n        result = result && isEqual_1.default(error.parentSchema, schema);\n      }\n\n      return result;\n    });\n  };\n};\n\nvar getErrorsAt = function getErrorsAt(instancePath, schema, matchPath) {\n  return function (state) {\n    return exports.errorsAt(instancePath, schema, matchPath)(state.errors);\n  };\n};\n\nexports.errorAt = function (instancePath, schema) {\n  return getErrorsAt(instancePath, schema, function (path) {\n    return path === instancePath;\n  });\n};\n\nexports.subErrorsAt = function (instancePath, schema) {\n  return getErrorsAt(instancePath, schema, function (path) {\n    return path.startsWith(instancePath);\n  });\n};\n\nexports.extractRefParserOptions = function (state) {\n  return get_1.default(state, 'refParserOptions');\n};","map":null,"metadata":{},"sourceType":"script"}