{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/dj/work/JSON-forms-parser-REACT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/dj/work/JSON-forms-parser-REACT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar $Ref = require(\"./ref\");\n\nvar Pointer = require(\"./pointer\");\n\nvar parse = require(\"./parse\");\n\nvar url = require(\"./util/url\");\n\nmodule.exports = resolveExternal;\n/**\n * Crawls the JSON schema, finds all external JSON references, and resolves their values.\n * This method does not mutate the JSON schema. The resolved values are added to {@link $RefParser#$refs}.\n *\n * NOTE: We only care about EXTERNAL references here. INTERNAL references are only relevant when dereferencing.\n *\n * @param {$RefParser} parser\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves once all JSON references in the schema have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\n\nfunction resolveExternal(parser, options) {\n  if (!options.resolve.external) {\n    // Nothing to resolve, so exit early\n    return Promise.resolve();\n  }\n\n  try {\n    // console.log('Resolving $ref pointers in %s', parser.$refs._root$Ref.path);\n    var promises = crawl(parser.schema, parser.$refs._root$Ref.path + \"#\", parser.$refs, options);\n    return Promise.all(promises);\n  } catch (e) {\n    return Promise.reject(e);\n  }\n}\n/**\n * Recursively crawls the given value, and resolves any external JSON references.\n *\n * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.\n * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise[]}\n * Returns an array of promises. There will be one promise for each JSON reference in `obj`.\n * If `obj` does not contain any JSON references, then the array will be empty.\n * If any of the JSON references point to files that contain additional JSON references,\n * then the corresponding promise will internally reference an array of promises.\n */\n\n\nfunction crawl(obj, path, $refs, options) {\n  var promises = [];\n\n  if (obj && typeof obj === \"object\") {\n    if ($Ref.isExternal$Ref(obj)) {\n      promises.push(resolve$Ref(obj, path, $refs, options));\n    } else {\n      for (var _i = 0, _Object$keys = Object.keys(obj); _i < _Object$keys.length; _i++) {\n        var key = _Object$keys[_i];\n        var keyPath = Pointer.join(path, key);\n        var value = obj[key];\n\n        if ($Ref.isExternal$Ref(value)) {\n          promises.push(resolve$Ref(value, keyPath, $refs, options));\n        } else {\n          promises = promises.concat(crawl(value, keyPath, $refs, options));\n        }\n      }\n    }\n  }\n\n  return promises;\n}\n/**\n * Resolves the given JSON Reference, and then crawls the resulting value.\n *\n * @param {{$ref: string}} $ref - The JSON Reference to resolve\n * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves once all JSON references in the object have been resolved,\n * including nested references that are contained in externally-referenced files.\n */\n\n\nfunction resolve$Ref(_x, _x2, _x3, _x4) {\n  return _resolve$Ref.apply(this, arguments);\n}\n\nfunction _resolve$Ref() {\n  _resolve$Ref = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee($ref, path, $refs, options) {\n    var resolvedPath, withoutHash, result, promises;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            // console.log('Resolving $ref pointer \"%s\" at %s', $ref.$ref, path);\n            resolvedPath = url.resolve(path, $ref.$ref);\n            withoutHash = url.stripHash(resolvedPath); // Do we already have this $ref?\n\n            $ref = $refs._$refs[withoutHash];\n\n            if (!$ref) {\n              _context.next = 5;\n              break;\n            }\n\n            return _context.abrupt(\"return\", Promise.resolve($ref.value));\n\n          case 5:\n            _context.next = 7;\n            return parse(resolvedPath, $refs, options);\n\n          case 7:\n            result = _context.sent;\n            // Crawl the parsed value\n            // console.log('Resolving $ref pointers in %s', withoutHash);\n            promises = crawl(result, withoutHash + \"#\", $refs, options);\n            return _context.abrupt(\"return\", Promise.all(promises));\n\n          case 10:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n  return _resolve$Ref.apply(this, arguments);\n}","map":null,"metadata":{},"sourceType":"script"}