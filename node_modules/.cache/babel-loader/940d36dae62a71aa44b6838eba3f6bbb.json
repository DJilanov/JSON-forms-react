{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/dj/work/JSON-forms-parser-REACT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/dj/work/JSON-forms-parser-REACT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _require = require(\"ono\"),\n    ono = _require.ono;\n\nvar url = require(\"./util/url\");\n\nvar plugins = require(\"./util/plugins\");\n\nmodule.exports = parse;\n/**\n * Reads and parses the specified file path or URL.\n *\n * @param {string} path - This path MUST already be resolved, since `read` doesn't know the resolution context\n * @param {$Refs} $refs\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents, NOT the raw (Buffer) contents.\n */\n\nfunction parse(_x, _x2, _x3) {\n  return _parse.apply(this, arguments);\n}\n/**\n * Reads the given file, using the configured resolver plugins\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the raw file contents and the resolver that was used.\n */\n\n\nfunction _parse() {\n  _parse = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(path, $refs, options) {\n    var $ref, file, resolver, parser;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.prev = 0;\n            // Remove the URL fragment, if any\n            path = url.stripHash(path); // Add a new $Ref for this file, even though we don't have the value yet.\n            // This ensures that we don't simultaneously read & parse the same file multiple times\n\n            $ref = $refs._add(path); // This \"file object\" will be passed to all resolvers and parsers.\n\n            file = {\n              url: path,\n              extension: url.getExtension(path)\n            }; // Read the file and then parse the data\n\n            _context.next = 6;\n            return readFile(file, options, $refs);\n\n          case 6:\n            resolver = _context.sent;\n            $ref.pathType = resolver.plugin.name;\n            file.data = resolver.result;\n            _context.next = 11;\n            return parseFile(file, options, $refs);\n\n          case 11:\n            parser = _context.sent;\n            $ref.value = parser.result;\n            return _context.abrupt(\"return\", parser.result);\n\n          case 16:\n            _context.prev = 16;\n            _context.t0 = _context[\"catch\"](0);\n            return _context.abrupt(\"return\", Promise.reject(_context.t0));\n\n          case 19:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, null, [[0, 16]]);\n  }));\n  return _parse.apply(this, arguments);\n}\n\nfunction readFile(file, options, $refs) {\n  return new Promise(function (resolve, reject) {\n    // console.log('Reading %s', file.url);\n    // Find the resolvers that can read this file\n    var resolvers = plugins.all(options.resolve);\n    resolvers = plugins.filter(resolvers, \"canRead\", file); // Run the resolvers, in order, until one of them succeeds\n\n    plugins.sort(resolvers);\n    plugins.run(resolvers, \"read\", file, $refs).then(resolve, onError);\n\n    function onError(err) {\n      // Throw the original error, if it's one of our own (user-friendly) errors.\n      // Otherwise, throw a generic, friendly error.\n      if (err && !(err instanceof SyntaxError)) {\n        reject(err);\n      } else {\n        reject(ono.syntax(\"Unable to resolve $ref pointer \\\"\".concat(file.url, \"\\\"\")));\n      }\n    }\n  });\n}\n/**\n * Parses the given file's contents, using the configured parser plugins.\n *\n * @param {object} file           - An object containing information about the referenced file\n * @param {string} file.url       - The full URL of the referenced file\n * @param {string} file.extension - The lowercased file extension (e.g. \".txt\", \".html\", etc.)\n * @param {*}      file.data      - The file contents. This will be whatever data type was returned by the resolver\n * @param {$RefParserOptions} options\n *\n * @returns {Promise}\n * The promise resolves with the parsed file contents and the parser that was used.\n */\n\n\nfunction parseFile(file, options, $refs) {\n  return new Promise(function (resolve, reject) {\n    // console.log('Parsing %s', file.url);\n    // Find the parsers that can read this file type.\n    // If none of the parsers are an exact match for this file, then we'll try ALL of them.\n    // This handles situations where the file IS a supported type, just with an unknown extension.\n    var allParsers = plugins.all(options.parse);\n    var filteredParsers = plugins.filter(allParsers, \"canParse\", file);\n    var parsers = filteredParsers.length > 0 ? filteredParsers : allParsers; // Run the parsers, in order, until one of them succeeds\n\n    plugins.sort(parsers);\n    plugins.run(parsers, \"parse\", file, $refs).then(onParsed, onError);\n\n    function onParsed(parser) {\n      if (!parser.plugin.allowEmpty && isEmpty(parser.result)) {\n        reject(ono.syntax(\"Error parsing \\\"\".concat(file.url, \"\\\" as \").concat(parser.plugin.name, \". \\nParsed value is empty\")));\n      } else {\n        resolve(parser);\n      }\n    }\n\n    function onError(err) {\n      if (err) {\n        err = err instanceof Error ? err : new Error(err);\n        reject(ono.syntax(err, \"Error parsing \".concat(file.url)));\n      } else {\n        reject(ono.syntax(\"Unable to parse \".concat(file.url)));\n      }\n    }\n  });\n}\n/**\n * Determines whether the parsed value is \"empty\".\n *\n * @param {*} value\n * @returns {boolean}\n */\n\n\nfunction isEmpty(value) {\n  return value === undefined || typeof value === \"object\" && Object.keys(value).length === 0 || typeof value === \"string\" && value.trim().length === 0 || Buffer.isBuffer(value) && value.length === 0;\n}","map":null,"metadata":{},"sourceType":"script"}