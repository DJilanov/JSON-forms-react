{"ast":null,"code":"\"use strict\";\n\nvar _regeneratorRuntime = require(\"/Users/dj/work/JSON-forms-parser-REACT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"/Users/dj/work/JSON-forms-parser-REACT/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar Options = require(\"./options\");\n\nvar $Refs = require(\"./refs\");\n\nvar parse = require(\"./parse\");\n\nvar normalizeArgs = require(\"./normalize-args\");\n\nvar resolveExternal = require(\"./resolve-external\");\n\nvar bundle = require(\"./bundle\");\n\nvar dereference = require(\"./dereference\");\n\nvar url = require(\"./util/url\");\n\nvar maybe = require(\"call-me-maybe\");\n\nvar _require = require(\"ono\"),\n    ono = _require.ono;\n\nmodule.exports = $RefParser;\nmodule.exports.YAML = require(\"./util/yaml\");\n/**\n * This class parses a JSON schema, builds a map of its JSON references and their resolved values,\n * and provides methods for traversing, manipulating, and dereferencing those references.\n *\n * @constructor\n */\n\nfunction $RefParser() {\n  /**\n   * The parsed (and possibly dereferenced) JSON schema object\n   *\n   * @type {object}\n   * @readonly\n   */\n  this.schema = null;\n  /**\n   * The resolved JSON references\n   *\n   * @type {$Refs}\n   * @readonly\n   */\n\n  this.$refs = new $Refs();\n}\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n\n\n$RefParser.parse = function (path, schema, options, callback) {\n  var Class = this; // eslint-disable-line consistent-this\n\n  var instance = new Class();\n  return instance.parse.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema.\n * This method does not resolve any JSON references.\n * It just reads a single file in JSON or YAML format, and parse it as a JavaScript object.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed\n * @param {function} [callback] - An error-first callback. The second parameter is the parsed JSON schema object.\n * @returns {Promise} - The returned promise resolves with the parsed JSON schema object.\n */\n\n\n$RefParser.prototype.parse =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(path, schema, options, callback) {\n    var args,\n        promise,\n        err,\n        pathType,\n        $ref,\n        me,\n        result,\n        _args = arguments;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            args = normalizeArgs(_args);\n\n            if (!(!args.path && !args.schema)) {\n              _context.next = 4;\n              break;\n            }\n\n            err = ono(\"Expected a file path, URL, or object. Got \".concat(args.path || args.schema));\n            return _context.abrupt(\"return\", maybe(args.callback, Promise.reject(err)));\n\n          case 4:\n            // Reset everything\n            this.schema = null;\n            this.$refs = new $Refs(); // If the path is a filesystem path, then convert it to a URL.\n            // NOTE: According to the JSON Reference spec, these should already be URLs,\n            // but, in practice, many people use local filesystem paths instead.\n            // So we're being generous here and doing the conversion automatically.\n            // This is not intended to be a 100% bulletproof solution.\n            // If it doesn't work for your use-case, then use a URL instead.\n\n            pathType = \"http\";\n\n            if (url.isFileSystemPath(args.path)) {\n              args.path = url.fromFileSystemPath(args.path);\n              pathType = \"file\";\n            } // Resolve the absolute path of the schema\n\n\n            args.path = url.resolve(url.cwd(), args.path);\n\n            if (args.schema && typeof args.schema === \"object\") {\n              // A schema object was passed-in.\n              // So immediately add a new $Ref with the schema object as its value\n              $ref = this.$refs._add(args.path);\n              $ref.value = args.schema;\n              $ref.pathType = pathType;\n              promise = Promise.resolve(args.schema);\n            } else {\n              // Parse the schema file/url\n              promise = parse(args.path, this.$refs, args.options);\n            }\n\n            me = this;\n            _context.prev = 11;\n            _context.next = 14;\n            return promise;\n\n          case 14:\n            result = _context.sent;\n\n            if (!(!result || typeof result !== \"object\" || Buffer.isBuffer(result))) {\n              _context.next = 19;\n              break;\n            }\n\n            throw ono.syntax(\"\\\"\".concat(me.$refs._root$Ref.path || result, \"\\\" is not a valid JSON Schema\"));\n\n          case 19:\n            me.schema = result;\n            return _context.abrupt(\"return\", maybe(args.callback, Promise.resolve(me.schema)));\n\n          case 21:\n            _context.next = 26;\n            break;\n\n          case 23:\n            _context.prev = 23;\n            _context.t0 = _context[\"catch\"](11);\n            return _context.abrupt(\"return\", maybe(args.callback, Promise.reject(_context.t0)));\n\n          case 26:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee, this, [[11, 23]]);\n  }));\n\n  return function (_x, _x2, _x3, _x4) {\n    return _ref.apply(this, arguments);\n  };\n}();\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n\n\n$RefParser.resolve = function (path, schema, options, callback) {\n  var Class = this; // eslint-disable-line consistent-this\n\n  var instance = new Class();\n  return instance.resolve.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema and resolves any JSON references, including references in\n * externally-referenced files.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed and resolved\n * @param {function} [callback]\n * - An error-first callback. The second parameter is a {@link $Refs} object containing the resolved JSON references\n *\n * @returns {Promise}\n * The returned promise resolves with a {@link $Refs} object containing the resolved JSON references\n */\n\n\n$RefParser.prototype.resolve =\n/*#__PURE__*/\nfunction () {\n  var _ref2 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(path, schema, options, callback) {\n    var me,\n        args,\n        _args2 = arguments;\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            me = this;\n            args = normalizeArgs(_args2);\n            _context2.prev = 2;\n            _context2.next = 5;\n            return this.parse(args.path, args.schema, args.options);\n\n          case 5:\n            _context2.next = 7;\n            return resolveExternal(me, args.options);\n\n          case 7:\n            return _context2.abrupt(\"return\", maybe(args.callback, Promise.resolve(me.$refs)));\n\n          case 10:\n            _context2.prev = 10;\n            _context2.t0 = _context2[\"catch\"](2);\n            return _context2.abrupt(\"return\", maybe(args.callback, Promise.reject(_context2.t0)));\n\n          case 13:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2, this, [[2, 10]]);\n  }));\n\n  return function (_x5, _x6, _x7, _x8) {\n    return _ref2.apply(this, arguments);\n  };\n}();\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n\n\n$RefParser.bundle = function (path, schema, options, callback) {\n  var Class = this; // eslint-disable-line consistent-this\n\n  var instance = new Class();\n  return instance.bundle.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema, resolves any JSON references, and bundles all external references\n * into the main JSON schema. This produces a JSON schema that only has *internal* references,\n * not any *external* references.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the bundled JSON schema object\n * @returns {Promise} - The returned promise resolves with the bundled JSON schema object.\n */\n\n\n$RefParser.prototype.bundle =\n/*#__PURE__*/\nfunction () {\n  var _ref3 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee3(path, schema, options, callback) {\n    var me,\n        args,\n        _args3 = arguments;\n    return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n      while (1) {\n        switch (_context3.prev = _context3.next) {\n          case 0:\n            me = this;\n            args = normalizeArgs(_args3);\n            _context3.prev = 2;\n            _context3.next = 5;\n            return this.resolve(args.path, args.schema, args.options);\n\n          case 5:\n            bundle(me, args.options);\n            return _context3.abrupt(\"return\", maybe(args.callback, Promise.resolve(me.schema)));\n\n          case 9:\n            _context3.prev = 9;\n            _context3.t0 = _context3[\"catch\"](2);\n            return _context3.abrupt(\"return\", maybe(args.callback, Promise.reject(_context3.t0)));\n\n          case 12:\n          case \"end\":\n            return _context3.stop();\n        }\n      }\n    }, _callee3, this, [[2, 9]]);\n  }));\n\n  return function (_x9, _x10, _x11, _x12) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n\n\n$RefParser.dereference = function (path, schema, options, callback) {\n  var Class = this; // eslint-disable-line consistent-this\n\n  var instance = new Class();\n  return instance.dereference.apply(instance, arguments);\n};\n/**\n * Parses the given JSON schema, resolves any JSON references, and dereferences the JSON schema.\n * That is, all JSON references are replaced with their resolved values.\n *\n * @param {string} [path] - The file path or URL of the JSON schema\n * @param {object} [schema] - A JSON schema object. This object will be used instead of reading from `path`.\n * @param {$RefParserOptions} [options] - Options that determine how the schema is parsed, resolved, and dereferenced\n * @param {function} [callback] - An error-first callback. The second parameter is the dereferenced JSON schema object\n * @returns {Promise} - The returned promise resolves with the dereferenced JSON schema object.\n */\n\n\n$RefParser.prototype.dereference =\n/*#__PURE__*/\nfunction () {\n  var _ref4 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee4(path, schema, options, callback) {\n    var me,\n        args,\n        _args4 = arguments;\n    return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n      while (1) {\n        switch (_context4.prev = _context4.next) {\n          case 0:\n            me = this;\n            args = normalizeArgs(_args4);\n            _context4.prev = 2;\n            _context4.next = 5;\n            return this.resolve(args.path, args.schema, args.options);\n\n          case 5:\n            dereference(me, args.options);\n            return _context4.abrupt(\"return\", maybe(args.callback, Promise.resolve(me.schema)));\n\n          case 9:\n            _context4.prev = 9;\n            _context4.t0 = _context4[\"catch\"](2);\n            return _context4.abrupt(\"return\", maybe(args.callback, Promise.reject(_context4.t0)));\n\n          case 12:\n          case \"end\":\n            return _context4.stop();\n        }\n      }\n    }, _callee4, this, [[2, 9]]);\n  }));\n\n  return function (_x13, _x14, _x15, _x16) {\n    return _ref4.apply(this, arguments);\n  };\n}();","map":null,"metadata":{},"sourceType":"script"}